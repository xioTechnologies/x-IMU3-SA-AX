/**
 * @file Adc.c
 * @author Seb Madgwick
 * @brief ADC driver.
 */

//------------------------------------------------------------------------------
// Includes

#include "Adc.h"
#include "definitions.h"
#include <stdint.h>

//------------------------------------------------------------------------------
// Definitions

/**
 * @brief Oversampling factor.  A oversampling factor of 64 is equivalent to an
 * extra 3 bits of resolution.
 */
#define OVERSAMPLING 16

/**
 * @brief Scaling for 12-bit resolution and 3000 mV reference.
 */
#define SCALING (3000.0f / ((float) OVERSAMPLING * 4095.0f))

/**
 * @brief Accumulator.
 */
typedef struct {
    uint32_t numberOfSamples;
    uint32_t ch1;
    uint32_t ch2;
    uint32_t ch3;
    uint32_t ch4;
    uint32_t ch5;
    uint32_t ch6;
    uint32_t ch7;
    uint32_t ch8;
} Accumulator;

//------------------------------------------------------------------------------
// Variables

static Accumulator accumulator;
static AdcData data;

//------------------------------------------------------------------------------
// Functions

/**
 * @brief Initialises module.  This function should be called once, on system
 * start up.
 */
void AdcInitialise(void) {

    // Load calibration
    ADC7CFG = DEVADC7;

    // Configure ADC control registers
    ADCCON1bits.STRGSRC = 0b00110; // TMR3 match
    ADCCON1bits.AICPMPEN = 0; // Analog input charge pump is disabled

    // ADC7 timing
    ADCCON2bits.ADCDIV = 1; // TAD = 2 * TQ
    ADCCON2bits.SAMC = 5;

    // Warm up timing
    ADCANCONbits.WKUPCLKCNT = 5;

    // Enable inputs for common scan
    ADCCSS1bits.CSS7 = 1;
    ADCCSS1bits.CSS8 = 1;
    ADCCSS1bits.CSS9 = 1;
    ADCCSS1bits.CSS10 = 1;
    ADCCSS1bits.CSS11 = 1;
    ADCCSS1bits.CSS12 = 1;
    ADCCSS1bits.CSS13 = 1;
    ADCCSS1bits.CSS14 = 1;

    // Set scan as trigger source
    ADCTRG2bits.TRGSRC7 = 0b00011;
    ADCTRG3bits.TRGSRC8 = 0b00011;
    ADCTRG3bits.TRGSRC9 = 0b00011;
    ADCTRG3bits.TRGSRC10 = 0b00011;
    ADCTRG3bits.TRGSRC11 = 0b00011;

    // Enable ADC
    ADCCON1bits.ON = 1;

    // Wait for voltage reference
    while (ADCCON2bits.BGVRRDY == 0);

    // Wake up ADC
    ADCANCONbits.ANEN7 = 1;

    // Wait for ADC to wake up
    while (ADCANCONbits.WKRDY7 == 0);

    // Enable digital ADC
    ADCCON3bits.DIGEN7 = 1;

    // Configure end of scan interrupt
    ADCCON2bits.EOSIEN = 1; // Interrupt will be generated when EOSRDY bit is set
    EVIC_SourceStatusClear(INT_SOURCE_ADC_EOS);
    EVIC_SourceEnable(INT_SOURCE_ADC_EOS);

    // Configure trigger timer
    PR3 = 750;
    T3CONbits.ON = 1;
}

/**
 * @brief ADC interrupt handler.  This function should be called by the ISR
 * implementation generated by MPLAB Harmony.
 */
void AdcInterruptHandler(void) {
    accumulator.numberOfSamples++;
    accumulator.ch1 += ADCDATA10;
    accumulator.ch2 += ADCDATA9;
    accumulator.ch3 += ADCDATA8;
    accumulator.ch4 += ADCDATA7;
    accumulator.ch5 += ADCDATA11;
    accumulator.ch6 += ADCDATA12;
    accumulator.ch7 += ADCDATA13;
    accumulator.ch8 += ADCDATA14;
    if (accumulator.numberOfSamples >= OVERSAMPLING) {
        data.counter++;
        data.ch1 = accumulator.ch1 * SCALING;
        data.ch2 = accumulator.ch2 * SCALING;
        data.ch3 = accumulator.ch3 * SCALING;
        data.ch4 = accumulator.ch4 * SCALING;
        data.ch5 = accumulator.ch5 * SCALING;
        data.ch6 = accumulator.ch6 * SCALING;
        data.ch7 = accumulator.ch7 * SCALING;
        data.ch8 = accumulator.ch8 * SCALING;
        static const Accumulator zeros;
        accumulator = zeros;
    }
    ADCCON2bits.EOSRDY = 0; // clear status bit else interrupt will persist
    EVIC_SourceStatusClear(INT_SOURCE_ADC_EOS);
}

/**
 * @brief Gets data.
 * @param data_ Data.
 */
void AdcGetData(AdcData * const data_) {
    do {
        *data_ = data;
    } while (data_->counter != data.counter);
}

//------------------------------------------------------------------------------
// End of file
